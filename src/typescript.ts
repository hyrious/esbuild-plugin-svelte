import type { PartialMessage, PluginBuild, TransformOptions } from 'esbuild'
import type { PreprocessorGroup } from 'svelte/compiler'

import { formatMessages, transform, version as esbuild_version } from 'esbuild'
import { existsSync } from 'fs'
import { readFile } from 'fs/promises'
import { basename, dirname, normalize, resolve } from 'path'
import { WriteStream } from 'tty'

type CompilerOptions = NonNullable<
  Exclude<TransformOptions['tsconfigRaw'], string | undefined>['compilerOptions']
>

export interface TypeScriptOptions {
  /** Passed to esbuild `tsconfigRaw` */
  compilerOptions?: CompilerOptions
  /** The esbuild instance come from context, use this instead of the default one */
  esbuild?: PluginBuild['esbuild']
  /** If not set, warnings will be printed to the console */
  onwarn?: (message: PartialMessage, defaultHandler?: (message: PartialMessage) => void) => void
}

export function typescript(options: TypeScriptOptions = {}): PreprocessorGroup {
  const onwarn = options.onwarn
  const warn = onwarn ? (message: PartialMessage) => onwarn(message, defaultHandler) : defaultHandler
  const compile = options.esbuild?.transform ?? transform

  return {
    // 'filename' is like './src/component.svelte', we need the './src' to resolve external imports
    async script({ attributes: { lang, src }, content, filename = 'source.svelte' }) {
      if (lang !== 'ts') return

      let dependencies: string[] | undefined
      if (typeof src === 'string') {
        const resolved = resolve(dirname(filename), src)
        if (existsSync(resolved)) {
          content = await readFile(resolved, 'utf8')
          dependencies = [resolved]
        } else {
          warn({
            text: `Could not find ${JSON.stringify(src)} from ${JSON.stringify(filename)}`,
            location: { file: filename },
          })
        }
      }

      const file_basename = basename(filename)

      // if an error occurs, the upstream plugin will handle it
      const { code, map, warnings } = await compile(content, {
        loader: 'ts',
        charset: 'utf8',
        // svelte preprocessor only handles basename, otherwise the sourcemap will be incorrect
        // but this config also affects the warnings generated by esbuild, fix them later
        sourcefile: file_basename,
        sourcemap: 'external',
        tsconfigRaw: {
          compilerOptions: Object.assign(
            defaultCompilerOptions(options.esbuild?.version ?? esbuild_version),
            options.compilerOptions,
          ),
        },
      })

      for (const w of warnings) {
        // fix the location in warnings, it may be wrong if multiple files share the same basename
        // esbuild always outputs normalized posix style paths (/), even on Windows
        if (w.location?.file === file_basename) w.location.file = normalize(filename).replace(/\\/g, '/')
        warn(w)
      }

      // the sourcemap is also wrong with a file basename, but svelte expects that,
      // so the fixing step is put in the other file, after the preprocessor combining all maps.
      return { code, map, dependencies }
    },
  }
}

function defaultCompilerOptions(version?: string): CompilerOptions {
  if (version) {
    const [major, minor] = version.split('.')
    if (Number(major) === 0 && Number(minor) < 18) {
      return { importsNotUsedAsValues: 'preserve', preserveValueImports: true }
    }
  }
  return { verbatimModuleSyntax: true }
}

async function defaultHandler(message: string | PartialMessage | PartialMessage[]) {
  message = typeof message === 'string' ? [{ text: message }] : makeArray(message)
  const result = await formatMessages(message, {
    kind: 'warning',
    color: WriteStream.prototype.hasColors(),
    terminalWidth: process.stderr.columns,
  })
  for (const string of result) {
    console.warn(string)
  }
}

export function makeArray<T>(a: T | T[]): T[] {
  return Array.isArray(a) ? a : [a]
}
