<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    * { font-family: monospace; }
    .active { background: yellow; }
  </style>
</head>
<body>
  <select id="sources"></select>
  <pre id="compiled"></pre>
  <script src="https://cdn.jsdelivr.net/npm/source-map@0.7.3/dist/source-map.js"></script>
  <script type="module">
    sourceMap.SourceMapConsumer.initialize({
      'lib/mappings.wasm': 'https://cdn.jsdelivr.net/npm/source-map@0.7.3/lib/mappings.wasm'
    })
    var source = '<script lang="ts">\n' +
          '  import { onMount } from "svelte";\n' +
          '  let a: number = 1;\n' +
          '<\/script>\n' +
          '\n' +
          '<button>{onMount} {a}</button>\n'
    var a = await new sourceMap.SourceMapConsumer({
      version: 3,
      mappings: ';;;;;;;;;;;SACE,OAAA,QAAA,QAAA;;;;;;;;2BAIO,OAAO,KAAG,CAAC;;;GAApB,MAA6B;;;;;;;;;;;IAHvB,CAAA,GAAY,CAAA;;;;;;;;;',
      names: [],
      sources: [ 'Button.svelte' ],
      sourcesContent: [
        source
      ]
    })
    var generated = `/* ./src/nested/Button.svelte generated by Svelte v3.44.2 */
import {
  SvelteComponent,
  detach,
  element,
  init,
  insert,
  noop,
  safe_not_equal
} from "svelte/internal";

import { onMount } from "svelte";

function create_fragment(ctx) {
  let button;

  return {
    c() {
      button = element("button");
      button.textContent = \`\${onMount}  \${a}\`;
    },
    m(target, anchor) {
      insert(target, button, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) detach(button);
    }
  };
}

let a = 1;

class Button extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment, safe_not_equal, {});
  }
}

export default Button;`


    source.split('\n').forEach((line, i) => {
      var o = document.createElement('option')
      o.value = i + 1
      o.innerText = `${(i + 1).toString().padStart(2)}| ${line}`;
      sources.append(o)
    })

    var mappings = {}

    a.eachMapping(mapping => {
      const {source, originalColumn, originalLine} = mapping
      const {generatedColumn, generatedLine} = mapping
      mappings[originalLine] ||= []
      mappings[originalLine].push([generatedLine, generatedColumn])
    })

    var generatedlines = { active: {} }

    generated.split('\n').forEach((line, i) => {
      var o = document.createElement('div')
      o.innerText = `${(i + 1).toString().padStart(2)}| ${line}`;
      generatedlines[i + 1] = o;
      compiled.append(o)
    })

    ;(sources.onchange = () => {
      let line = sources.value
      let to = mappings[line]
      for (let l in generatedlines.active) {
        generatedlines[l].classList.remove("active")
      }
      generatedlines.active = {}
      if (to) {
        for (let [l, c] of to) {
          generatedlines[l].classList.add("active")
          generatedlines.active[l] = true
        }
      }
    })();
  </script>
</body>
</html>
